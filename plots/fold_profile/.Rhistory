scale_fill_gradientn(
colors = c("gray", "blue", "red"), # Gradiente de colores
trans = "log10", # Transformación logarítmica base 10
limits = c(global_min, global_max), # Usar límites globales
na.value = "white", # NA en blanco
labels = scales::scientific # Etiquetas en notación científica
) +
scale_x_continuous(
breaks = seq(0, ncol(matrix_data), by = 10), # Mostrar cada 10 columnas
labels = seq(0, ncol(matrix_data), by = 10) # Etiquetar con los números de las columnas
) +
scale_y_continuous(
breaks = seq(0, nrow(matrix_data), by = 10), # Mostrar cada 10 filas
labels = seq(0, nrow(matrix_data), by = 10) # Etiquetar con los números de las filas
) +
labs(
x = "Residue b",
y = "Residue a",
fill = "Value (log10)",
title = paste("Heatmap of Matrix", matrix_index)
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
axis.text.y = element_text(size = 10)
)
return(heatmap_plot)
}
# Parámetros
file_path <- "fold_profile.txt"
matrix_size <- 128 # Dimensión de las matrices
# Leer las matrices del archivo
matrices <- read_matrices(file_path, matrix_size)
# Calcular el rango global de los valores de todas las matrices
global_min <- min(sapply(matrices, min, na.rm = TRUE))
global_max <- max(sapply(matrices, max, na.rm = TRUE))
# Crear heatmaps para todas las matrices con la misma escala de colores
for (i in seq_along(matrices)) {
heatmap <- create_heatmap(matrices[[i]], i, global_min, global_max)
# Guardar cada heatmap como archivo con nombre de dos dígitos
ggsave(
filename = sprintf("Heatmaps/heatmap_matrix_%02d.jpg", i),
plot = heatmap,
width = 8,
height = 6
)
}
library(ggplot2)
library(reshape2)
library(scales) # Para la notación científica en los ejes
# Leer todas las matrices desde el archivo y separarlas en una lista
read_matrices <- function(file_path, matrix_size) {
data <- as.matrix(read.table(file_path, header = FALSE))
num_matrices <- nrow(data) / matrix_size
matrices <- lapply(1:num_matrices, function(i) {
data[((i - 1) * matrix_size + 1):(i * matrix_size), ]
})
return(matrices)
}
# Crear heatmap para una matriz con escala global fija
create_heatmap <- function(matrix_data, matrix_index, global_min, global_max) {
# Crear la matriz diagonalizada para que la parte superior izquierda sea NA
matrix_data_upper_white <- matrix_data
matrix_data_upper_white[lower.tri(matrix_data_upper_white, diag = TRUE)] <- NA
# Convertir la matriz modificada a formato largo
matrix_long <- melt(matrix_data_upper_white)
colnames(matrix_long) <- c("Row", "Column", "Value") # Renombrar las columnas
# Crear el mapa de calor con escala logarítmica
heatmap_plot <- ggplot(matrix_long, aes(x = Column, y = Row, fill = Value)) +
geom_raster(na.rm = FALSE) + # Transición suave sin bordes
scale_fill_gradientn(
colors = c("gray", "blue", "red"), # Gradiente de colores
limits = c(global_min, global_max), # Usar límites globales
trans = "log10", # Transformación logarítmica base 10
na.value = "white", # NA en blanco
labels = scales::scientific # Etiquetas en notación científica
) +
scale_x_continuous(
breaks = seq(0, ncol(matrix_data), by = 10), # Mostrar cada 10 columnas
labels = seq(0, ncol(matrix_data), by = 10) # Etiquetar con los números de las columnas
) +
scale_y_continuous(
breaks = seq(0, nrow(matrix_data), by = 10), # Mostrar cada 10 filas
labels = seq(0, nrow(matrix_data), by = 10) # Etiquetar con los números de las filas
) +
labs(
x = "Residue b",
y = "Residue a",
fill = "Value (log10)",
title = paste("Heatmap of Matrix", sprintf("%02d", matrix_index))
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
axis.text.y = element_text(size = 10)
)
return(heatmap_plot)
}
# Parámetros
file_path <- "fold_profile.txt"
matrix_size <- 128 # Dimensión de las matrices
# Leer las matrices del archivo
matrices <- read_matrices(file_path, matrix_size)
# Calcular el rango global de los valores de todas las matrices
global_min <- min(sapply(matrices, function(x) min(x, na.rm = TRUE)))
global_max <- max(sapply(matrices, function(x) max(x, na.rm = TRUE)))
# Crear heatmaps para todas las matrices con la misma escala de colores
for (i in seq_along(matrices)) {
heatmap <- create_heatmap(matrices[[i]], i, global_min, global_max)
# Guardar cada heatmap como archivo con nombre de dos dígitos
ggsave(
filename = sprintf("Heatmaps/heatmap_matrix_%02d.jpg", i),
plot = heatmap,
width = 8,
height = 6
)
}
library(ggplot2)
library(reshape2)
library(scales) # Para la notación científica en los ejes
# Leer todas las matrices desde el archivo y separarlas en una lista
read_matrices <- function(file_path, matrix_size) {
data <- as.matrix(read.table(file_path, header = FALSE))
num_matrices <- nrow(data) / matrix_size
matrices <- lapply(1:num_matrices, function(i) {
data[((i - 1) * matrix_size + 1):(i * matrix_size), ]
})
return(matrices)
}
# Crear heatmap para una matriz con escala global fija
create_heatmap <- function(matrix_data, matrix_index, global_min, global_max) {
# Crear la matriz diagonalizada para que la parte superior izquierda sea NA
matrix_data_upper_white <- matrix_data
matrix_data_upper_white[lower.tri(matrix_data_upper_white, diag = TRUE)] <- NA
# Convertir la matriz modificada a formato largo
matrix_long <- melt(matrix_data_upper_white)
colnames(matrix_long) <- c("Row", "Column", "Value") # Renombrar las columnas
# Asegurarse de que las columnas "Row" y "Column" sean numéricas
matrix_long$Row <- as.numeric(matrix_long$Row)
matrix_long$Column <- as.numeric(matrix_long$Column)
# Crear el mapa de calor con escala logarítmica
heatmap_plot <- ggplot(matrix_long, aes(x = Column, y = Row, fill = Value)) +
geom_raster(na.rm = FALSE) + # Transición suave sin bordes
scale_fill_gradientn(
colors = c("gray", "blue", "red"), # Gradiente de colores
limits = c(global_min, global_max), # Usar límites globales
trans = "log10", # Transformación logarítmica base 10
na.value = "white", # NA en blanco
labels = scales::scientific # Etiquetas en notación científica
) +
scale_x_continuous(
breaks = seq(0, ncol(matrix_data), by = 10), # Mostrar cada 10 columnas
labels = seq(0, ncol(matrix_data), by = 10) # Etiquetar con los números de las columnas
) +
scale_y_continuous(
breaks = seq(0, nrow(matrix_data), by = 10), # Mostrar cada 10 filas
labels = seq(0, nrow(matrix_data), by = 10) # Etiquetar con los números de las filas
) +
labs(
x = "Residue b",
y = "Residue a",
fill = "Value (log10)",
title = paste("Heatmap of Matrix", sprintf("%02d", matrix_index))
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
library(ggplot2)
library(reshape2)
library(scales) # Para la notación científica en los ejes
# Leer todas las matrices desde el archivo y separarlas en una lista
read_matrices <- function(file_path, matrix_size) {
data <- as.matrix(read.table(file_path, header = FALSE))
num_matrices <- nrow(data) / matrix_size
matrices <- lapply(1:num_matrices, function(i) {
data[((i - 1) * matrix_size + 1):(i * matrix_size), ]
})
return(matrices)
}
# Crear heatmap para una matriz con escala global fija
create_heatmap <- function(matrix_data, matrix_index, global_min, global_max) {
# Crear la matriz diagonalizada para que la parte superior izquierda sea NA
matrix_data_upper_white <- matrix_data
matrix_data_upper_white[lower.tri(matrix_data_upper_white, diag = TRUE)] <- NA
# Convertir la matriz modificada a formato largo
matrix_long <- melt(matrix_data_upper_white)
colnames(matrix_long) <- c("Row", "Column", "Value") # Renombrar las columnas
# Asegurarse de que las columnas "Row" y "Column" sean numéricas
matrix_long$Row <- as.numeric(matrix_long$Row)
matrix_long$Column <- as.numeric(matrix_long$Column)
# Crear el mapa de calor con escala logarítmica
heatmap_plot <- ggplot(matrix_long, aes(x = Column, y = Row, fill = Value)) +
geom_raster(na.rm = FALSE) + # Transición suave sin bordes
scale_fill_gradientn(
colors = c("gray", "blue", "red"), # Gradiente de colores
limits = c(global_min, global_max), # Usar límites globales
trans = "log10", # Transformación logarítmica base 10
na.value = "white", # NA en blanco
labels = scales::scientific # Etiquetas en notación científica
) +
scale_x_continuous(
breaks = seq(0, ncol(matrix_data), by = 10), # Mostrar cada 10 columnas
labels = seq(0, ncol(matrix_data), by = 10) # Etiquetar con los números de las columnas
) +
scale_y_continuous(
breaks = seq(0, nrow(matrix_data), by = 10), # Mostrar cada 10 filas
labels = seq(0, nrow(matrix_data), by = 10) # Etiquetar con los números de las filas
) +
labs(
x = "Residue b",
y = "Residue a",
fill = "Value (log10)",
title = paste("Heatmap of Matrix", sprintf("%02d", matrix_index))
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
axis.text.y = element_text(size = 10)
)
return(heatmap_plot)
}
# Parámetros
file_path <- "fold_profile.txt"
matrix_size <- 128 # Dimensión de las matrices
# Leer las matrices del archivo
matrices <- read_matrices(file_path, matrix_size)
# Calcular el rango global de los valores de todas las matrices
global_min <- min(sapply(matrices, function(x) min(x, na.rm = TRUE)))
global_max <- max(sapply(matrices, function(x) max(x, na.rm = TRUE)))
# Crear heatmaps para todas las matrices con la misma escala de colores
for (i in seq_along(matrices)) {
heatmap <- create_heatmap(matrices[[i]], i, global_min, global_max)
# Guardar cada heatmap como archivo con nombre de dos dígitos
ggsave(
filename = sprintf("Heatmaps/heatmap_matrix_%02d.jpg", i),
plot = heatmap,
width = 8,
height = 6
)
}
library(ggplot2)
library(reshape2)
library(scales) # Para la notación científica en los ejes
# Leer todas las matrices desde el archivo y separarlas en una lista
read_matrices <- function(file_path, matrix_size) {
data <- as.matrix(read.table(file_path, header = FALSE))
num_matrices <- nrow(data) / matrix_size
matrices <- lapply(1:num_matrices, function(i) {
data[((i - 1) * matrix_size + 1):(i * matrix_size), ]
})
return(matrices)
}
# Crear heatmap para una matriz con escala global fija
create_heatmap <- function(matrix_data, matrix_index, global_min, global_max, breaks) {
# Crear la matriz diagonalizada para que la parte superior izquierda sea NA
matrix_data_upper_white <- matrix_data
matrix_data_upper_white[lower.tri(matrix_data_upper_white, diag = TRUE)] <- NA
# Convertir la matriz modificada a formato largo
matrix_long <- melt(matrix_data_upper_white)
colnames(matrix_long) <- c("Row", "Column", "Value") # Renombrar las columnas
# Asegurarse de que las columnas "Row" y "Column" sean numéricas
matrix_long$Row <- as.numeric(matrix_long$Row)
matrix_long$Column <- as.numeric(matrix_long$Column)
# Crear el mapa de calor con escala logarítmica
heatmap_plot <- ggplot(matrix_long, aes(x = Column, y = Row, fill = Value)) +
geom_raster(na.rm = FALSE) + # Transición suave sin bordes
scale_fill_gradientn(
colors = c("gray", "blue", "red"), # Gradiente de colores
limits = c(global_min, global_max), # Usar límites globales
breaks = breaks, # Divisiones específicas para la leyenda
labels = scales::scientific(breaks), # Etiquetas en notación científica
trans = "log10", # Transformación logarítmica base 10
na.value = "white" # NA en blanco
) +
scale_x_continuous(
breaks = seq(0, ncol(matrix_data), by = 10), # Mostrar cada 10 columnas
labels = seq(0, ncol(matrix_data), by = 10) # Etiquetar con los números de las columnas
) +
scale_y_continuous(
breaks = seq(0, nrow(matrix_data), by = 10), # Mostrar cada 10 filas
labels = seq(0, nrow(matrix_data), by = 10) # Etiquetar con los números de las filas
) +
labs(
x = "Residue b",
y = "Residue a",
fill = "Value (log10)",
title = paste("Heatmap of Matrix", sprintf("%02d", matrix_index))
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
axis.text.y = element_text(size = 10)
)
return(heatmap_plot)
}
# Parámetros
file_path <- "fold_profile.txt"
matrix_size <- 128 # Dimensión de las matrices
# Leer las matrices del archivo
matrices <- read_matrices(file_path, matrix_size)
# Calcular el rango global de los valores de todas las matrices
global_min <- min(sapply(matrices, function(x) min(x, na.rm = TRUE)))
global_max <- max(sapply(matrices, function(x) max(x, na.rm = TRUE)))
# Crear divisiones consistentes para la leyenda
log_breaks <- scales::log_breaks(base = 10)(c(global_min, global_max))
library(ggplot2)
library(reshape2)
library(scales) # Para la notación científica en los ejes
# Leer todas las matrices desde el archivo y separarlas en una lista
read_matrices <- function(file_path, matrix_size) {
data <- as.matrix(read.table(file_path, header = FALSE))
num_matrices <- nrow(data) / matrix_size
matrices <- lapply(1:num_matrices, function(i) {
data[((i - 1) * matrix_size + 1):(i * matrix_size), ]
})
return(matrices)
}
# Crear heatmap para una matriz con escala global fija
create_heatmap <- function(matrix_data, matrix_index, global_min, global_max, breaks) {
# Crear la matriz diagonalizada para que la parte superior izquierda sea NA
matrix_data_upper_white <- matrix_data
matrix_data_upper_white[lower.tri(matrix_data_upper_white, diag = TRUE)] <- NA
# Convertir la matriz modificada a formato largo
matrix_long <- melt(matrix_data_upper_white)
colnames(matrix_long) <- c("Row", "Column", "Value") # Renombrar las columnas
# Asegurarse de que las columnas "Row" y "Column" sean numéricas
matrix_long$Row <- as.numeric(matrix_long$Row)
matrix_long$Column <- as.numeric(matrix_long$Column)
# Crear el mapa de calor con escala logarítmica
heatmap_plot <- ggplot(matrix_long, aes(x = Column, y = Row, fill = Value)) +
geom_raster(na.rm = FALSE) + # Transición suave sin bordes
scale_fill_gradientn(
colors = c("gray", "blue", "red"), # Gradiente de colores
limits = c(global_min, global_max), # Usar límites globales
breaks = breaks, # Divisiones específicas para la leyenda
labels = scales::scientific(breaks), # Etiquetas en notación científica
trans = "log10", # Transformación logarítmica base 10
na.value = "white" # NA en blanco
) +
scale_x_continuous(
breaks = seq(0, ncol(matrix_data), by = 10), # Mostrar cada 10 columnas
labels = seq(0, ncol(matrix_data), by = 10) # Etiquetar con los números de las columnas
) +
scale_y_continuous(
breaks = seq(0, nrow(matrix_data), by = 10), # Mostrar cada 10 filas
labels = seq(0, nrow(matrix_data), by = 10) # Etiquetar con los números de las filas
) +
labs(
x = "Residue b",
y = "Residue a",
fill = "Value (log10)",
title = paste("Heatmap of Matrix", sprintf("%02d", matrix_index))
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
axis.text.y = element_text(size = 10)
)
return(heatmap_plot)
}
# Parámetros
file_path <- "fold_profile.txt"
matrix_size <- 128 # Dimensión de las matrices
# Leer las matrices del archivo
matrices <- read_matrices(file_path, matrix_size)
# Calcular el rango global de los valores de todas las matrices
global_min <- min(sapply(matrices, function(x) min(x, na.rm = TRUE)))
global_max <- max(sapply(matrices, function(x) max(x, na.rm = TRUE)))
# Crear divisiones consistentes para la leyenda
log_breaks <- scales::log_breaks(base = 10)(c(global_min, global_max))
library(ggplot2)
library(reshape2)
library(scales) # Para la notación científica en los ejes
# Leer todas las matrices desde el archivo y separarlas en una lista
read_matrices <- function(file_path, matrix_size) {
data <- as.matrix(read.table(file_path, header = FALSE))
num_matrices <- nrow(data) / matrix_size
matrices <- lapply(1:num_matrices, function(i) {
data[((i - 1) * matrix_size + 1):(i * matrix_size), ]
})
return(matrices)
}
# Crear heatmap para una matriz con escala global fija
create_heatmap <- function(matrix_data, matrix_index, global_min, global_max, breaks) {
# Crear la matriz diagonalizada para que la parte superior izquierda sea NA
matrix_data_upper_white <- matrix_data
matrix_data_upper_white[lower.tri(matrix_data_upper_white, diag = TRUE)] <- NA
# Convertir la matriz modificada a formato largo
matrix_long <- melt(matrix_data_upper_white)
colnames(matrix_long) <- c("Row", "Column", "Value") # Renombrar las columnas
# Asegurarse de que las columnas "Row" y "Column" sean numéricas
matrix_long$Row <- as.numeric(matrix_long$Row)
matrix_long$Column <- as.numeric(matrix_long$Column)
# Crear el mapa de calor con escala logarítmica
heatmap_plot <- ggplot(matrix_long, aes(x = Column, y = Row, fill = Value)) +
geom_raster(na.rm = FALSE) + # Transición suave sin bordes
scale_fill_gradientn(
colors = c("gray", "blue", "red"), # Gradiente de colores
limits = c(global_min, global_max), # Usar límites globales
breaks = breaks, # Divisiones específicas para la leyenda
labels = scales::scientific(breaks), # Etiquetas en notación científica
trans = "log10", # Transformación logarítmica base 10
na.value = "white" # NA en blanco
) +
scale_x_continuous(
breaks = seq(0, ncol(matrix_data), by = 10), # Mostrar cada 10 columnas
labels = seq(0, ncol(matrix_data), by = 10) # Etiquetar con los números de las columnas
) +
scale_y_continuous(
breaks = seq(0, nrow(matrix_data), by = 10), # Mostrar cada 10 filas
labels = seq(0, nrow(matrix_data), by = 10) # Etiquetar con los números de las filas
) +
labs(
x = "Residue b",
y = "Residue a",
fill = "Value (log10)",
title = paste("Heatmap of Matrix", sprintf("%02d", matrix_index))
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
axis.text.y = element_text(size = 10)
)
return(heatmap_plot)
}
# Parámetros
file_path <- "fold_profile.txt"
matrix_size <- 128 # Dimensión de las matrices
# Leer las matrices del archivo
matrices <- read_matrices(file_path, matrix_size)
# Calcular el rango global de los valores de todas las matrices
global_min <- min(sapply(matrices, function(x) min(x, na.rm = TRUE)), na.rm = TRUE)
global_max <- max(sapply(matrices, function(x) max(x, na.rm = TRUE)), na.rm = TRUE)
# Verificar si el rango es válido
if (is.na(global_min) || is.na(global_max) || global_min == global_max) {
stop("El rango global de los valores no es válido. Verifique los datos de entrada.")
}
# Crear divisiones consistentes para la leyenda
log_breaks <- scales::log_breaks(base = 10)(c(global_min, global_max))
library(ggplot2)
library(reshape2)
library(scales) # Para la notación científica en los ejes
# Leer todas las matrices desde el archivo y separarlas en una lista
read_matrices <- function(file_path, matrix_size) {
data <- as.matrix(read.table(file_path, header = FALSE))
num_matrices <- nrow(data) / matrix_size
matrices <- lapply(1:num_matrices, function(i) {
data[((i - 1) * matrix_size + 1):(i * matrix_size), ]
})
return(matrices)
}
# Crear heatmap para una matriz con escala global fija
create_heatmap <- function(matrix_data, matrix_index, global_min, global_max) {
# Crear la matriz diagonalizada para que la parte superior izquierda sea NA
matrix_data_upper_white <- matrix_data
matrix_data_upper_white[lower.tri(matrix_data_upper_white, diag = TRUE)] <- NA
# Convertir la matriz modificada a formato largo
matrix_long <- melt(matrix_data_upper_white)
colnames(matrix_long) <- c("Row", "Column", "Value") # Renombrar las columnas
# Asegurarse de que las columnas "Row" y "Column" sean numéricas
matrix_long$Row <- as.numeric(matrix_long$Row)
matrix_long$Column <- as.numeric(matrix_long$Column)
# Crear el mapa de calor con escala logarítmica
heatmap_plot <- ggplot(matrix_long, aes(x = Column, y = Row, fill = Value)) +
geom_raster(na.rm = FALSE) + # Transición suave sin bordes
scale_fill_gradientn(
colors = c("gray", "blue", "red"), # Gradiente de colores
limits = c(global_min, global_max), # Usar límites globales
trans = "log10", # Transformación logarítmica base 10
na.value = "white", # NA en blanco
labels = scales::scientific # Etiquetas en notación científica
) +
scale_x_continuous(
breaks = seq(0, ncol(matrix_data), by = 10), # Mostrar cada 10 columnas
labels = seq(0, ncol(matrix_data), by = 10) # Etiquetar con los números de las columnas
) +
scale_y_continuous(
breaks = seq(0, nrow(matrix_data), by = 10), # Mostrar cada 10 filas
labels = seq(0, nrow(matrix_data), by = 10) # Etiquetar con los números de las filas
) +
labs(
x = "Residue b",
y = "Residue a",
fill = "Value (log10)",
title = paste("Heatmap of Matrix", sprintf("%02d", matrix_index))
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, hjust = 1),
axis.text.y = element_text(size = 10)
)
return(heatmap_plot)
}
# Parámetros
file_path <- "fold_profile.txt"
matrix_size <- 128 # Dimensión de las matrices
# Leer las matrices del archivo
matrices <- read_matrices(file_path, matrix_size)
# Calcular el rango global de los valores de todas las matrices
global_min <- min(sapply(matrices, function(x) min(x, na.rm = TRUE)))
global_max <- max(sapply(matrices, function(x) max(x, na.rm = TRUE)))
# Crear heatmaps para todas las matrices con la misma escala de colores
for (i in seq_along(matrices)) {
heatmap <- create_heatmap(matrices[[i]], i, global_min, global_max)
# Guardar cada heatmap como archivo con nombre de dos dígitos
ggsave(
filename = sprintf("Heatmaps/heatmap_matrix_%02d.jpg", i),
plot = heatmap,
width = 8,
height = 6
)
}
