return(-3/2 * k_B * (term1 + term2))
}
# Llenar la matriz S_ij
for (row in 1:nrow(data)) {
i <- data[row, "i"]
j <- data[row, "j"]
r_ij <- data[row, "r_ij"]
# Verificar que i y j estén dentro de los límites y que i < j
if (i < j && i >= 1 && j <= n) {
L <- j - i
S_matrix[i, j] <- entropy_Ooka(L, r_ij, a, A, k_B)
}
}
# Reemplazar los NA por ceros (opcional, si prefieres)
S_matrix[is.na(S_matrix)] <- 0
# Graficar la matriz S_ij con leyenda
image.plot(1:n, 1:n, t(S_matrix), col=topo.colors(100), xlab="i", ylab="j",
main="Mapa de calor de la matriz S_ij con leyenda")
grid()
library(fields)
# Definir parámetros
a <- 3.8
A <- 20
k_B <- 1 #1.38e-23  # Constante de Boltzmann en Joules/Kelvin
# Leer el archivo rCalpha.txt que contiene i, j y r_ij
data <- read.table("rCalpha.txt", header=FALSE)
colnames(data) <- c("i", "j", "r_ij")
# Crear una matriz vacía para S_ij
n <- 120
S_matrix <- matrix(NA, n, n)  # Usamos NA en vez de 0 para identificar valores no calculados
# Función para calcular la entropía S'(L)
entropy_Ooka <- function(L, r, a, A, k_B) {
term1 <- log(L)
term2 <- (r^2 - a^2) / (2 * A * a * L)
return(-3/2 * k_B * (term1 + term2))
}
# Llenar la matriz S_ij
for (row in 1:nrow(data)) {
i <- data[row, "i"]
j <- data[row, "j"]
r_ij <- data[row, "r_ij"]
# Verificar que i y j estén dentro de los límites y que i < j
if (i < j && i >= 1 && j <= n) {
L <- j - i
S_matrix[i, j] <- entropy_Ooka(L, r_ij, a, A, k_B)
}
}
# Reemplazar los NA por ceros (opcional, si prefieres)
S_matrix[is.na(S_matrix)] <- 0
# Graficar la matriz S_ij con leyenda
image.plot(1:n, 1:n, t(S_matrix), col=topo.colors(100), xlab="i", ylab="j",
main="Mapa de calor de la matriz S_ij con leyenda")
grid()
# Graficar la matriz S_ij con leyenda
image.plot(1:n, 1:n, t(S_matrix), col=topo.colors(100), xlab="i", ylab="j",
main="S_ij (i<j) with Kb=1")
# Cargar librerías
library(ggplot2)
library(dplyr)
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Definir constantes
lp <- 6 # longitud de persistencia en Ångstroms
pi <- 3.141592653589793
# Definir función para calcular e(4, i, j)
calculate_entropy <- function(i, j, r) {
lc <- (j - i + 2) * 3.8
d <- r
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) - (79.0 * d^6 / (160.0 * lp * lc^5)) +
(329.0 * d^8 / (120.0 * lp * lc^7)) - (6799.0 * d^10 / (1600.0 * lp * lc^9)) +
(34441.0 * d^12 / (2800.0 * lp * lc^11)) - (1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- -1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Calcular S y L para los valores deseados de j-i (0, 1, 2)
data <- rCalpha_data %>%
filter(j - i %in% c(0, 1, 2)) %>%
mutate(
L = (j - i + 2) * 3.8,
S = mapply(calculate_entropy, i, j, r)
)
# Cargar librerías
library(ggplot2)
library(dplyr)
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Definir constantes
lp <- 6 # longitud de persistencia en Ångstroms
pi <- 3.141592653589793
# Definir función para calcular e(4, i, j)
calculate_entropy <- function(i, j, r) {
lc <- (j - i + 2) * 3.8
d <- r
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) - (79.0 * d^6 / (160.0 * lp * lc^5)) +
(329.0 * d^8 / (120.0 * lp * lc^7)) - (6799.0 * d^10 / (1600.0 * lp * lc^9)) +
(34441.0 * d^12 / (2800.0 * lp * lc^11)) - (1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- -1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Calcular S y L para los valores deseados de j-i (0, 1, 2)
data <- rCalpha_data %>%
filter(j - i %in% c(0, 1, 2)) %>%
mutate(
L = (j - i + 2) * 3.8,
S = mapply(calculate_entropy, i, j, r)
)
# Cargar librerías
library(ggplot2)
library(dplyr)
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Definir constantes
lp <- 6 # longitud de persistencia en Ångstroms
pi <- 3.141592653589793
# Definir función para calcular e(4, i, j)
calculate_entropy <- function(i, j, r) {
lc <- (j - i) * 3.8
d <- r
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) - (79.0 * d^6 / (160.0 * lp * lc^5)) +
(329.0 * d^8 / (120.0 * lp * lc^7)) - (6799.0 * d^10 / (1600.0 * lp * lc^9)) +
(34441.0 * d^12 / (2800.0 * lp * lc^11)) - (1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- -1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Añadir columna de diferencia (j - i) y filtrar los valores deseados
data <- rCalpha_data %>%
mutate(diff = j - i) %>%
filter(diff %in% c(0, 1, 2)) %>%
mutate(
L = (diff + 2) * 3.8,
S = mapply(calculate_entropy, i, j, r)
)
# Graficar S en función de L usando ggplot2
ggplot(data, aes(x = L, y = S, color = as.factor(diff))) +
geom_line() +
labs(
title = "Entropía S en función de L para valores específicos de j - i",
x = "L (Å)",
y = "S",
color = "j - i"
) +
scale_x_log10() + # Escala logarítmica para el eje x
theme_minimal()
# Cargar librerías
library(ggplot2)
library(dplyr)
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Definir constantes
lp <- 6 # longitud de persistencia en Ångstroms
pi <- 3.141592653589793
# Definir función para calcular e(4, i, j)
calculate_entropy <- function(i, j, r) {
lc <- (j - i+2) * 3.8
d <- r
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) - (79.0 * d^6 / (160.0 * lp * lc^5)) +
(329.0 * d^8 / (120.0 * lp * lc^7)) - (6799.0 * d^10 / (1600.0 * lp * lc^9)) +
(34441.0 * d^12 / (2800.0 * lp * lc^11)) - (1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- -1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Añadir columna de diferencia (j - i) y filtrar los valores deseados
data <- rCalpha_data %>%
mutate(diff = j - i) %>%
filter(diff %in% c(0, 1, 2)) %>%
mutate(
L = (diff + 2) * 3.8,
S = mapply(calculate_entropy, i, j, r)
)
# Graficar S en función de L usando ggplot2
ggplot(data, aes(x = L, y = S, color = as.factor(diff))) +
geom_line() +
labs(
title = "Entropía S en función de L para valores específicos de j - i",
x = "L (Å)",
y = "S",
color = "j - i"
) +
scale_x_log10() + # Escala logarítmica para el eje x
theme_minimal()
library(ggplot2)
# Parámetros
lp <- 6  # Longitud de persistencia en Amstrongs
# Define la función para el primer cálculo de S
calc_S1 <- function(r, delta_ji) {
1.5 * log(delta_ji + 1) + 1.5 * (r^2 - 3.8^2) / ((delta_ji + 2) * 2 * 20 * 3.8)
}
# Define la función para el segundo cálculo de S y w
calc_S2 <- function(d, delta_ji) {
lc <- delta_ji * 3.8
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) +
(79.0 * lp^2 / (160.0 * lc^2)) +
(329.0 * d^2 * lp / (120.0 * lc^3)) -
(6799.0 * d^4 / (1600.0 * lc^4)) +
(3441.0 * d^6 / (2800.0 * lp * lc^5)) -
(1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- -1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Generar los datos para j - i = 0, 1, 2 con los dos términos de S
data <- do.call(rbind, lapply(0:2, function(delta_ji) {
# Para el primer término de S
r_values <- seq(0, (delta_ji + 2) * 3.8, length.out = 100)
S1_values <- sapply(r_values, calc_S1, delta_ji = delta_ji)
# Para el segundo término de S
d_values <- seq(0, (delta_ji + 2) * 3.8, length.out = 100)
S2_values <- sapply(d_values, calc_S2, delta_ji = delta_ji)
# Combinar datos
data.frame(
r = c(r_values, d_values),
S = c(S1_values, S2_values),
delta_ji = factor(delta_ji),
type = rep(c("j-i=1", "j-i=2"), each = 100)
)
}))
# Graficar usando ggplot
ggplot(data, aes(x = r, y = S, color = delta_ji, linetype = type)) +
geom_line(size = 1) +
labs(x = "L=(j-i+2)a", y = "S",
color = "Ooka j-i", linetype = "Zhou") +
theme_minimal() +
ggtitle("Gráfico de los dos términos de S en función de la distancia para diferentes valores de j - i")
# Cargar librerías
library(ggplot2)
library(dplyr)
# Parámetros
lp <- 6  # Longitud de persistencia en Amstrongs
pi <- 3.141592653589793
# Define la función para el primer cálculo de S
calc_S1 <- function(r, delta_ji) {
1.5 * log(delta_ji + 1) + 1.5 * (r^2 - 3.8^2) / ((delta_ji + 2) * 2 * 20 * 3.8)
}
# Define la función para el segundo cálculo de S y w
calc_S2 <- function(d, delta_ji) {
lc <- delta_ji * 3.8
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) +
(79.0 * lp^2 / (160.0 * lc^2)) +
(329.0 * d^2 * lp / (120.0 * lc^3)) -
(6799.0 * d^4 / (1600.0 * lc^4)) +
(3441.0 * d^6 / (2800.0 * lp * lc^5)) -
(1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- -1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Filtrar y procesar los datos para los valores de j - i = 0, 1, 2
data <- do.call(rbind, lapply(0:2, function(delta_ji) {
# Filtrar datos donde j - i = delta_ji
r_values <- rCalpha_data %>% filter((j - i) == delta_ji) %>% pull(r)
# Calcular S1 para los valores de r de rCalpha.txt
S1_values <- sapply(r_values, calc_S1, delta_ji = delta_ji)
# Calcular S2 para valores de d generados
d_values <- seq(0, (delta_ji + 2) * 3.8, length.out = 100)
S2_values <- sapply(d_values, calc_S2, delta_ji = delta_ji)
# Combinar los datos en un solo data frame
data.frame(
r = c(r_values, d_values),
S = c(S1_values, S2_values),
delta_ji = factor(delta_ji),
type = rep(c("S1", "S2"), c(length(r_values), length(d_values)))
)
}))
# Cargar librerías
library(ggplot2)
library(dplyr)
# Parámetros
lp <- 3.04  # Longitud de persistencia en Amstrongs
pi <- 3.141592653589793
# Define la función para el primer cálculo de S
calc_S1 <- function(r, delta_ji) {
1.5 * log(delta_ji + 1) + 1.5 * (r^2 - 3.8^2) / ((delta_ji + 2) * 2 * 20 * 3.8)
}
# Define la función para el segundo cálculo de S y w
calc_S2 <- function(d, delta_ji) {
lc <- (delta_ji+2) * 3.8
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) +
(79.0 * lp^2 / (160.0 * lc^2)) +
(329.0 * d^2 * lp / (120.0 * lc^3)) -
(6799.0 * d^4 / (1600.0 * lc^4)) +
(3441.0 * d^6 / (2800.0 * lp * lc^5)) -
(1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- 1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Filtrar y procesar los datos para los valores de j - i = 0, 1, 2
data <- do.call(rbind, lapply(0:2, function(delta_ji) {
# Filtrar datos donde j - i = delta_ji
r_values <- rCalpha_data %>% filter((j - i) == delta_ji) %>% pull(r)
# Calcular S1 para los valores de r de rCalpha.txt
S1_values <- sapply(r_values, calc_S1, delta_ji = delta_ji)
# Calcular S2 para valores de d generados
d_values <- seq(0, (delta_ji + 2) * 3.8, length.out = 100)
S2_values <- sapply(d_values, calc_S2, delta_ji = delta_ji)
# Combinar los datos en un solo data frame
data.frame(
r = c(r_values, d_values),
S = c(S1_values, S2_values),
delta_ji = factor(delta_ji),
type = rep(c("S1", "S2"), c(length(r_values), length(d_values)))
)
}))
# Cargar librerías
library(ggplot2)
library(dplyr)
# Parámetros
lp <- 6  # Longitud de persistencia en Amstrongs
pi <- 3.141592653589793
# Define la función para el primer cálculo de S
calc_S1 <- function(r, delta_ji) {
1.5 * log(delta_ji + 1) + 1.5 * (r^2 - 3.8^2) / ((delta_ji + 2) * 2 * 20 * 3.8)
}
# Define la función para el segundo cálculo de S y w
calc_S2 <- function(d, delta_ji) {
lc <- delta_ji * 3.8
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) +
(79.0 * lp^2 / (160.0 * lc^2)) +
(329.0 * d^2 * lp / (120.0 * lc^3)) -
(6799.0 * d^4 / (1600.0 * lc^4)) +
(3441.0 * d^6 / (2800.0 * lp * lc^5)) -
(1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- -1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Filtrar y procesar los datos para los valores de j - i = 0, 1, 2
data <- bind_rows(lapply(0:2, function(delta_ji) {
# Filtrar datos donde j - i = delta_ji
filtered_data <- rCalpha_data %>% filter((j - i) == delta_ji)
r_values <- filtered_data$r
# Calcular S1 para los valores de r de rCalpha.txt
S1_values <- sapply(r_values, calc_S1, delta_ji = delta_ji)
# Calcular S2 para valores de d generados
d_values <- seq(0, (delta_ji + 2) * 3.8, length.out = 100)
S2_values <- sapply(d_values, calc_S2, delta_ji = delta_ji)
# Combinar los datos en un solo data frame
data.frame(
r = c(r_values, d_values),
S = c(S1_values, S2_values),
delta_ji = factor(delta_ji),
type = rep(c("S1", "S2"), c(length(S1_values), length(S2_values)))
)
}))
# Graficar usando ggplot
ggplot(data, aes(x = r, y = S, color = delta_ji, linetype = type)) +
geom_line(size = 1) +
labs(x = "L = (j - i + 2) * 3.8 Å", y = "S",
color = "j - i", linetype = "Término de S") +
theme_minimal() +
ggtitle("Gráfico de los dos términos de S en función de la distancia para diferentes valores de j - i")
# Cargar librerías
library(ggplot2)
library(dplyr)
# Parámetros
lp <- 6  # Longitud de persistencia en Amstrongs
pi <- 3.141592653589793
# Define la función para el primer cálculo de S
calc_S1 <- function(r, delta_ji) {
1.5 * log(delta_ji + 1) + 1.5 * (r^2 - 3.8^2) / ((delta_ji + 2) * 2 * 20 * 3.8)
}
# Define la función para el segundo cálculo de S y w
calc_S2 <- function(d, delta_ji) {
lc <- (delta_ji+2) * 3.8
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) +
(79.0 * lp^2 / (160.0 * lc^2)) +
(329.0 * d^2 * lp / (120.0 * lc^3)) -
(6799.0 * d^4 / (1600.0 * lc^4)) +
(3441.0 * d^6 / (2800.0 * lp * lc^5)) -
(1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- 1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Filtrar y procesar los datos para los valores de j - i = 0, 1, 2
data <- bind_rows(lapply(0:2, function(delta_ji) {
# Filtrar datos donde j - i = delta_ji
filtered_data <- rCalpha_data %>% filter((j - i) == delta_ji)
r_values <- filtered_data$r
# Calcular S1 para los valores de r de rCalpha.txt
S1_values <- sapply(r_values, calc_S1, delta_ji = delta_ji)
# Calcular S2 para valores de d generados
d_values <- seq(0, (delta_ji + 2) * 3.8, length.out = 100)
S2_values <- sapply(d_values, calc_S2, delta_ji = delta_ji)
# Combinar los datos en un solo data frame
data.frame(
r = c(r_values, d_values),
S = c(S1_values, S2_values),
delta_ji = factor(delta_ji),
type = rep(c("S1", "S2"), c(length(S1_values), length(S2_values)))
)
}))
# Graficar usando ggplot
ggplot(data, aes(x = r, y = S, color = delta_ji, linetype = type)) +
geom_line(size = 1) +
labs(x = "L = (j - i + 2) * 3.8 Å", y = "S",
color = "j - i", linetype = "Término de S") +
theme_minimal() +
ggtitle("Gráfico de los dos términos de S en función de la distancia para diferentes valores de j - i")
# Cargar librerías
library(ggplot2)
library(dplyr)
# Parámetros
lp <- 3.04  # Longitud de persistencia en Amstrongs
pi <- 3.141592653589793
# Define la función para el primer cálculo de S
calc_S1 <- function(r, delta_ji) {
1.5 * log(delta_ji + 1) + 1.5 * (r^2 - 3.8^2) / ((delta_ji + 2) * 2 * 20 * 3.8)
}
# Define la función para el segundo cálculo de S y w
calc_S2 <- function(d, delta_ji) {
lc <- (delta_ji+2) * 3.8
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) +
(79.0 * lp^2 / (160.0 * lc^2)) +
(329.0 * d^2 * lp / (120.0 * lc^3)) -
(6799.0 * d^4 / (1600.0 * lc^4)) +
(3441.0 * d^6 / (2800.0 * lp * lc^5)) -
(1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- 1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Filtrar y procesar los datos para los valores de j - i = 0, 1, 2
data <- bind_rows(lapply(0:2, function(delta_ji) {
# Filtrar datos donde j - i = delta_ji
filtered_data <- rCalpha_data %>% filter((j - i) == delta_ji)
r_values <- filtered_data$r
# Calcular S1 para los valores de r de rCalpha.txt
S1_values <- sapply(r_values, calc_S1, delta_ji = delta_ji)
# Calcular S2 para valores de d generados
d_values <- seq(0, (delta_ji + 2) * 3.8, length.out = 100)
S2_values <- sapply(d_values, calc_S2, delta_ji = delta_ji)
# Combinar los datos en un solo data frame
data.frame(
r = c(r_values, d_values),
S = c(S1_values, S2_values),
delta_ji = factor(delta_ji),
type = rep(c("S1", "S2"), c(length(S1_values), length(S2_values)))
)
}))
# Graficar usando ggplot
ggplot(data, aes(x = r, y = S, color = delta_ji, linetype = type)) +
geom_line(size = 1) +
labs(x = "L = (j - i + 2) * 3.8 Å", y = "S",
color = "j - i", linetype = "Término de S") +
theme_minimal() +
ggtitle("Gráfico de los dos términos de S en función de la distancia para diferentes valores de j - i")
View(rCalpha_data)
# Cargar librerías
library(ggplot2)
library(dplyr)
# Parámetros
lp <- 3.04  # Longitud de persistencia en Amstrongs
pi <- 3.141592653589793
# Define la función para el primer cálculo de S
calc_S1 <- function(r, delta_ji) {
1.5 * log(delta_ji + 2) + 1.5 * (r^2 - 3.8^2) / ((delta_ji + 2) * 2 * 20 * 3.8)
}
# Define la función para el segundo cálculo de S y w
calc_S2 <- function(d, delta_ji) {
lc <- (delta_ji+2) * 3.8
w <- (5.0 * lp / (4.0 * lc)) - (2.0 * d^2 / lc^2) +
(33.0 * d^4 / (80.0 * lp * lc^3)) +
(79.0 * lp^2 / (160.0 * lc^2)) +
(329.0 * d^2 * lp / (120.0 * lc^3)) -
(6799.0 * d^4 / (1600.0 * lc^4)) +
(3441.0 * d^6 / (2800.0 * lp * lc^5)) -
(1089.0 * d^8 / (12800.0 * lp^2 * lc^6))
S <- 1.5 * log(4 * pi * lp * lc / 3) - 3 * d^2 / (4 * lp * lc) + log(1 - w)
return(S)
}
# Leer los datos de rCalpha.txt
rCalpha_data <- read.table("rCalpha.txt", header = FALSE, col.names = c("i", "j", "r"))
# Filtrar y procesar los datos para los valores de j - i = 0, 1, 2
data <- bind_rows(lapply(0:2, function(delta_ji) {
# Filtrar datos donde j - i = delta_ji
filtered_data <- rCalpha_data %>% filter((j - i) == delta_ji)
r_values <- filtered_data$r
# Calcular S1 para los valores de r de rCalpha.txt
S1_values <- sapply(r_values, calc_S1, delta_ji = delta_ji)
# Calcular S2 para valores de d generados
d_values <- seq(0, (delta_ji + 2) * 3.8, length.out = 100)
S2_values <- sapply(d_values, calc_S2, delta_ji = delta_ji)
# Combinar los datos en un solo data frame
data.frame(
r = c(r_values, d_values),
S = c(S1_values, S2_values),
delta_ji = factor(delta_ji),
type = rep(c("S1", "S2"), c(length(S1_values), length(S2_values)))
)
}))
# Graficar usando ggplot
ggplot(data, aes(x = r, y = S, color = delta_ji, linetype = type)) +
geom_line(size = 1) +
labs(x = "L = (j - i + 2) * 3.8 Å", y = "S",
color = "j - i", linetype = "Término de S") +
theme_minimal() +
ggtitle("Gráfico de los dos términos de S en función de la distancia para diferentes valores de j - i")
