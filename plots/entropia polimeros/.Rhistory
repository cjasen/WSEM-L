library(dplyr)
library(tidyr)
calc_Q <- function(d, delta_ji,lp) {
a <- 14.054
b <- 0.473
Lc <- (delta_ji + 2) * 3.8
kappa <- lp / Lc
d <- d/Lc
c <- 1 - (1 + (0.38 * kappa^(-0.95))^-5)^(-1/5)
d_val <- ifelse(kappa < 1/8, 0, 1 / (0.177 / (kappa - 0.111) + 6.40 * (kappa - 0.111)^0.783))
cij <- matrix(
c(-3/4, 23/64, -7/64,
-1/2, 17/16, -9/16),
nrow = 2, byrow = TRUE
)
J_SYD <- ifelse(kappa <= 1/8, (3/4 * pi * kappa)^(3/2) * (1 - 5 * kappa / 4),
112.04 * kappa^2 * exp(0.246 / kappa - a * kappa))
term1 <- ((1 - c * d^2) / (1 - d^2))^(5/2)
term2 <- 0
i_values <- c(-1, 0)
j_values <- 1:3
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
term2 <- term2 + cij[i, j] * kappa^i_values[i] * d^(2 * j_values[j])
}
}
term2 <- exp(term2 / (1 - d^2))
term3 <- exp(-d_val * kappa * a * b * (1 + b) * d^2 / (1 - b^2 * d^2))
term4 <- besselI(-d_val * kappa * a * (1 + b) * d / (1 - b^2 * d^2), nu = 0)
Q_r <- J_SYD * term1 * term2 * term3 * term4
return(Q_r)
}
# Params
L <- 13
lp <- 2.1
# Valores de r
r_values <- seq(7, 35, by = 1)
# Calcula p(r)
p_values <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, L, lp))
# Leer los datos experimentales
zhou_data <- read.table("zhou_data.txt", header = FALSE, col.names = c("r", "p"))
zhou_data$r <- as.numeric(zhou_data$r)
zhou_data$p <- as.numeric(zhou_data$p)
# Rango de los valores calculados
min_calculated <- min(p_values)
max_calculated <- max(p_values)
# Rango de los valores de zhou_data
min_zhou <- min(zhou_data$p)
max_zhou <- max(zhou_data$p)
# Transformación lineal
zhou_data$p_transformed <- min_calculated +
(max_calculated - min_calculated) * (zhou_data$p - min_zhou) / (max_zhou - min_zhou)
# Crea un dataframe para ggplot
df <- data.frame(r = r_values, p = p_values)
ggplot() +
geom_line(data = df, aes(x = r, y = p), color = "blue", size = 1, linetype = "solid") +
geom_point(data = zhou_data, aes(x = r, y = p_transformed), color = "red", size = 2) +
labs(
x = "r",
y = "p(r)",
color = "Datos") +
theme_minimal()
library(ggplot2)
library(dplyr)
library(tidyr)
calc_Q <- function(d, delta_ji,lp) {
a <- 14.054
b <- 0.473
Lc <- (delta_ji + 2) * 3.8
kappa <- lp / Lc
d <- d/Lc
c <- 1 - (1 + (0.38 * kappa^(-0.95))^-5)^(-1/5)
d_val <- ifelse(kappa < 1/8, 0, 1 / (0.177 / (kappa - 0.111) + 6.40 * (kappa - 0.111)^0.783))
cij <- matrix(
c(-3/4, 23/64, -7/64,
-1/2, 17/16, -9/16),
nrow = 2, byrow = TRUE
)
J_SYD <- ifelse(kappa <= 1/8, (3/4 * pi * kappa)^(3/2) * (1 - 5 * kappa / 4),
112.04 * kappa^2 * exp(0.246 / kappa - a * kappa))
term1 <- ((1 - c * d^2) / (1 - d^2))^(5/2)
term2 <- 0
i_values <- c(-1, 0)
j_values <- 1:3
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
term2 <- term2 + cij[i, j] * kappa^i_values[i] * d^(2 * j_values[j])
}
}
term2 <- exp(term2 / (1 - d^2))
term3 <- exp(-d_val * kappa * a * b * (1 + b) * d^2 / (1 - b^2 * d^2))
term4 <- besselI(-d_val * kappa * a * (1 + b) * d / (1 - b^2 * d^2), nu = 0)
Q_r <- J_SYD * term1 * term2 * term3 * term4
return(Q_r)
}
# Params
L <- 13
lp <- 2.1
# Valores de r
r_values <- seq(7, 35, by = 1)
# Calcula p(r)
p_values <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, L, lp))
# Leer los datos experimentales
zhou_data <- read.table("zhou_data.txt", header = FALSE, col.names = c("r", "p"))
zhou_data$r <- as.numeric(zhou_data$r)
zhou_data$p <- as.numeric(zhou_data$p)
# Rango de los valores calculados
min_calculated <- min(p_values)
max_calculated <- max(p_values)
# Rango de los valores de zhou_data
min_zhou <- min(zhou_data$p)
max_zhou <- max(zhou_data$p)
# Transformación lineal
zhou_data$p_transformed <- min_calculated +
(max_calculated - min_calculated) * (zhou_data$p - min_zhou) / (max_zhou - min_zhou)
# Crea un dataframe para ggplot
df <- data.frame(r = r_values, p = p_values)
ggplot() +
geom_line(data = df, aes(x = r, y = p), color = "blue", size = 1, linetype = "solid") +
geom_point(data = zhou_data, aes(x = r, y = p_transformed), color = "red", size = 2) +
labs(
x = "r",
y = "p(r,lp)",
color = "Datos") +
theme_minimal()
library(ggplot2)
library(dplyr)
library(tidyr)
# Función calc_Q adaptada
calc_Q <- function(d, delta_ji, lp) {
a <- 14.054
b <- 0.473
Lc <- (delta_ji + 2) * 3.8
kappa <- lp / Lc
d <- d / Lc
c <- 1 - (1 + (0.38 * kappa^(-0.95))^-5)^(-1 / 5)
d_val <- ifelse(kappa < 1 / 8, 0, 1 / (0.177 / (kappa - 0.111) + 6.40 * (kappa - 0.111)^0.783))
cij <- matrix(
c(-3 / 4, 23 / 64, -7 / 64,
-1 / 2, 17 / 16, -9 / 16),
nrow = 2, byrow = TRUE
)
J_SYD <- ifelse(kappa <= 1 / 8, (3 / 4 * pi * kappa)^(3 / 2) * (1 - 5 * kappa / 4),
112.04 * kappa^2 * exp(0.246 / kappa - a * kappa))
term1 <- ((1 - c * d^2) / (1 - d^2))^(5 / 2)
term2 <- 0
i_values <- c(-1, 0)
j_values <- 1:3
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
term2 <- term2 + cij[i, j] * kappa^i_values[i] * d^(2 * j_values[j])
}
}
term2 <- exp(term2 / (1 - d^2))
term3 <- exp(-d_val * kappa * a * b * (1 + b) * d^2 / (1 - b^2 * d^2))
term4 <- besselI(-d_val * kappa * a * (1 + b) * d / (1 - b^2 * d^2), nu = 0)
Q_r <- J_SYD * term1 * term2 * term3 * term4
return(Q_r)
}
# Función para calcular el error
calc_error <- function(lp, zhou_data) {
# Valores de r
r_values <- zhou_data$r
# Calcula p(r) para el lp dado
p_values <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, 13, lp))
# Normaliza los datos experimentales
min_calculated <- min(p_values)
max_calculated <- max(p_values)
zhou_data$p_transformed <- min_calculated +
(max_calculated - min_calculated) * (zhou_data$p - min(zhou_data$p)) /
(max(zhou_data$p) - min(zhou_data$p))
# Calcula el error como suma de los cuadrados de las diferencias
error <- sum((zhou_data$p_transformed - p_values)^2)
return(error)
}
# Carga los datos experimentales
zhou_data <- read.table("zhou_data.txt", header = FALSE, col.names = c("r", "p"))
zhou_data$r <- as.numeric(zhou_data$r)
zhou_data$p <- as.numeric(zhou_data$p)
# Optimización para encontrar el mejor lp
result <- optim(par = 2.1, fn = calc_error, zhou_data = zhou_data, method = "Brent", lower = 0.1, upper = 10)
# Mejor valor de lp
best_lp <- result$par
cat("El mejor valor de lp es:", best_lp, "\n")
# Calcula p(r) con el mejor lp
r_values <- seq(7, 35, by = 1)
p_values <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, 13, best_lp))
# Normaliza los datos experimentales
min_calculated <- min(p_values)
max_calculated <- max(p_values)
zhou_data$p_transformed <- min_calculated +
(max_calculated - min_calculated) * (zhou_data$p - min(zhou_data$p)) /
(max(zhou_data$p) - min(zhou_data$p))
# Crea un dataframe para ggplot
df <- data.frame(r = r_values, p = p_values)
# Gráfica
ggplot() +
geom_line(data = df, aes(x = r, y = p), color = "blue", size = 1, linetype = "solid") +
geom_point(data = zhou_data, aes(x = r, y = p_transformed), color = "red", size = 2) +
labs(
title = paste("Mejor ajuste con lp =", round(best_lp, 2)),
x = "r",
y = "p(r, lp)",
color = "Datos"
) +
theme_minimal()
library(ggplot2)
library(dplyr)
library(tidyr)
# Función calc_Q adaptada
calc_Q <- function(d, delta_ji, lp) {
a <- 14.054
b <- 0.473
Lc <- (delta_ji + 2) * 3.8
kappa <- lp / Lc
d <- d / Lc
c <- 1 - (1 + (0.38 * kappa^(-0.95))^-5)^(-1 / 5)
d_val <- ifelse(kappa < 1 / 8, 0, 1 / (0.177 / (kappa - 0.111) + 6.40 * (kappa - 0.111)^0.783))
cij <- matrix(
c(-3 / 4, 23 / 64, -7 / 64,
-1 / 2, 17 / 16, -9 / 16),
nrow = 2, byrow = TRUE
)
J_SYD <- ifelse(kappa <= 1 / 8, (3 / 4 * pi * kappa)^(3 / 2) * (1 - 5 * kappa / 4),
112.04 * kappa^2 * exp(0.246 / kappa - a * kappa))
term1 <- ((1 - c * d^2) / (1 - d^2))^(5 / 2)
term2 <- 0
i_values <- c(-1, 0)
j_values <- 1:3
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
term2 <- term2 + cij[i, j] * kappa^i_values[i] * d^(2 * j_values[j])
}
}
term2 <- exp(term2 / (1 - d^2))
term3 <- exp(-d_val * kappa * a * b * (1 + b) * d^2 / (1 - b^2 * d^2))
term4 <- besselI(-d_val * kappa * a * (1 + b) * d / (1 - b^2 * d^2), nu = 0)
Q_r <- J_SYD * term1 * term2 * term3 * term4
return(Q_r)
}
# Leer los datos experimentales
zhou_data <- read.table("zhou_data.txt", header = FALSE, col.names = c("r", "p"))
zhou_data$r <- as.numeric(zhou_data$r)
zhou_data$p <- as.numeric(zhou_data$p)
# Transformar los datos experimentales antes de la optimización
# Usando valores iniciales aproximados para el rango
initial_lp <- 2.1
r_values <- seq(7, 35, by = 1)
p_values_initial <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, 13, initial_lp))
min_calculated <- min(p_values_initial)
max_calculated <- max(p_values_initial)
min_zhou <- min(zhou_data$p)
max_zhou <- max(zhou_data$p)
zhou_data$p_transformed <- min_calculated +
(max_calculated - min_calculated) * (zhou_data$p - min_zhou) / (max_zhou - min_zhou)
# Función para calcular el error
calc_error <- function(lp, zhou_data) {
# Calcula p(r) para el lp dado
p_values <- 4 * pi * zhou_data$r^2 * sapply(zhou_data$r, function(r) calc_Q(r, 13, lp))
# Calcula el error como suma de los cuadrados de las diferencias
error <- sum((zhou_data$p_transformed - p_values)^2)
return(error)
}
# Optimización para encontrar el mejor lp
result <- optim(par = 2.1, fn = calc_error, zhou_data = zhou_data, method = "Brent", lower = 0.1, upper = 10)
# Mejor valor de lp
best_lp <- result$par
cat("El mejor valor de lp es:", best_lp, "\n")
# Calcula p(r) con el mejor lp
p_values <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, 13, best_lp))
# Crea un dataframe para ggplot
df <- data.frame(r = r_values, p = p_values)
# Gráfica
ggplot() +
geom_line(data = df, aes(x = r, y = p), color = "blue", size = 1, linetype = "solid") +
geom_point(data = zhou_data, aes(x = r, y = p_transformed), color = "red", size = 2) +
labs(
title = paste("Mejor ajuste con lp =", round(best_lp, 2)),
x = "r",
y = "p(r, lp)",
color = "Datos"
) +
theme_minimal()
library(ggplot2)
library(dplyr)
library(tidyr)
calc_Q <- function(d, delta_ji,lp) {
a <- 14.054
b <- 0.473
Lc <- (delta_ji + 2) * 3.8
kappa <- lp / Lc
d <- d/Lc
c <- 1 - (1 + (0.38 * kappa^(-0.95))^-5)^(-1/5)
d_val <- ifelse(kappa < 1/8, 0, 1 / (0.177 / (kappa - 0.111) + 6.40 * (kappa - 0.111)^0.783))
cij <- matrix(
c(-3/4, 23/64, -7/64,
-1/2, 17/16, -9/16),
nrow = 2, byrow = TRUE
)
J_SYD <- ifelse(kappa <= 1/8, (3/4 * pi * kappa)^(3/2) * (1 - 5 * kappa / 4),
112.04 * kappa^2 * exp(0.246 / kappa - a * kappa))
term1 <- ((1 - c * d^2) / (1 - d^2))^(5/2)
term2 <- 0
i_values <- c(-1, 0)
j_values <- 1:3
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
term2 <- term2 + cij[i, j] * kappa^i_values[i] * d^(2 * j_values[j])
}
}
term2 <- exp(term2 / (1 - d^2))
term3 <- exp(-d_val * kappa * a * b * (1 + b) * d^2 / (1 - b^2 * d^2))
term4 <- besselI(-d_val * kappa * a * (1 + b) * d / (1 - b^2 * d^2), nu = 0)
Q_r <- J_SYD * term1 * term2 * term3 * term4
return(Q_r)
}
# Params
L <- 13
lp <- 2.1
# Valores de r
r_values <- seq(7, 35, by = 1)
# Calcula p(r)
p_values <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, L, lp))
# Leer los datos experimentales
zhou_data <- read.table("zhou_data.txt", header = FALSE, col.names = c("r", "p"))
zhou_data$r <- as.numeric(zhou_data$r)
zhou_data$p <- as.numeric(zhou_data$p)
# Rango de los valores calculados
min_calculated <- min(p_values)
max_calculated <- max(p_values)
# Rango de los valores de zhou_data
min_zhou <- min(zhou_data$p)
max_zhou <- max(zhou_data$p)
# Transformación lineal
zhou_data$p_transformed <- min_calculated +
(max_calculated - min_calculated) * (zhou_data$p - min_zhou) / (max_zhou - min_zhou)
# Crea un dataframe para ggplot
df <- data.frame(r = r_values, p = p_values)
ggplot() +
geom_line(data = df, aes(x = r, y = p), color = "blue", size = 1, linetype = "solid") +
geom_point(data = zhou_data, aes(x = r, y = p_transformed), color = "red", size = 2) +
labs(
x = "r",
y = "p(r,lp)",
color = "Datos") +
theme_minimal()
library(ggplot2)
library(dplyr)
library(tidyr)
# Función calc_Q adaptada
calc_Q <- function(d, delta_ji, lp) {
a <- 14.054
b <- 0.473
Lc <- (delta_ji + 2) * 3.8
kappa <- lp / Lc
d <- d / Lc
c <- 1 - (1 + (0.38 * kappa^(-0.95))^-5)^(-1 / 5)
d_val <- ifelse(kappa < 1 / 8, 0, 1 / (0.177 / (kappa - 0.111) + 6.40 * (kappa - 0.111)^0.783))
cij <- matrix(
c(-3 / 4, 23 / 64, -7 / 64,
-1 / 2, 17 / 16, -9 / 16),
nrow = 2, byrow = TRUE
)
J_SYD <- ifelse(kappa <= 1 / 8, (3 / 4 * pi * kappa)^(3 / 2) * (1 - 5 * kappa / 4),
112.04 * kappa^2 * exp(0.246 / kappa - a * kappa))
term1 <- ((1 - c * d^2) / (1 - d^2))^(5 / 2)
term2 <- 0
i_values <- c(-1, 0)
j_values <- 1:3
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
term2 <- term2 + cij[i, j] * kappa^i_values[i] * d^(2 * j_values[j])
}
}
term2 <- exp(term2 / (1 - d^2))
term3 <- exp(-d_val * kappa * a * b * (1 + b) * d^2 / (1 - b^2 * d^2))
term4 <- besselI(-d_val * kappa * a * (1 + b) * d / (1 - b^2 * d^2), nu = 0)
Q_r <- J_SYD * term1 * term2 * term3 * term4
return(Q_r)
}
# Leer los datos experimentales
zhou_data <- read.table("zhou_data.txt", header = FALSE, col.names = c("r", "p"))
zhou_data$r <- as.numeric(zhou_data$r)
zhou_data$p <- as.numeric(zhou_data$p)
# Transformar los datos experimentales antes de la optimización
# Usando valores iniciales aproximados para el rango
initial_lp <- 2.1
r_values <- seq(7, 35, by = 1)
p_values_initial <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, 13, initial_lp))
min_calculated <- min(p_values_initial)
max_calculated <- max(p_values_initial)
min_zhou <- min(zhou_data$p)
max_zhou <- max(zhou_data$p)
zhou_data$p_transformed <- min_calculated +
(max_calculated - min_calculated) * (zhou_data$p - min_zhou) / (max_zhou - min_zhou)
# Función para calcular el error
calc_error <- function(lp, zhou_data) {
# Calcula p(r) para el lp dado
p_values <- 4 * pi * zhou_data$r^2 * sapply(zhou_data$r, function(r) calc_Q(r, 13, lp))
# Calcula el error como suma de los cuadrados de las diferencias
error <- sum((zhou_data$p_transformed - p_values)^2)
return(error)
}
# Optimización para encontrar el mejor lp
result <- optim(par = 2.1, fn = calc_error, zhou_data = zhou_data, method = "Brent", lower = 0.1, upper = 10)
# Mejor valor de lp
best_lp <- result$par
cat("El mejor valor de lp es:", best_lp, "\n")
# Calcula p(r) con el mejor lp
p_values <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, 13, best_lp))
# Crea un dataframe para ggplot
df <- data.frame(r = r_values, p = p_values)
# Gráfica
ggplot() +
geom_line(data = df, aes(x = r, y = p), color = "blue", size = 1, linetype = "solid") +
geom_point(data = zhou_data, aes(x = r, y = p_transformed), color = "red", size = 2) +
labs(
title = paste("Mejor ajuste con lp =", round(best_lp, 2)),
x = "r",
y = "p(r, lp)",
color = "Datos"
) +
theme_minimal()
library(ggplot2)
library(dplyr)
library(tidyr)
# Función calc_Q adaptada
calc_Q <- function(d, delta_ji, lp) {
a <- 14.054
b <- 0.473
Lc <- (delta_ji + 2) * 3.8
kappa <- lp / Lc
d <- d / Lc
c <- 1 - (1 + (0.38 * kappa^(-0.95))^-5)^(-1 / 5)
d_val <- ifelse(kappa < 1 / 8, 0, 1 / (0.177 / (kappa - 0.111) + 6.40 * (kappa - 0.111)^0.783))
cij <- matrix(
c(-3 / 4, 23 / 64, -7 / 64,
-1 / 2, 17 / 16, -9 / 16),
nrow = 2, byrow = TRUE
)
J_SYD <- ifelse(kappa <= 1 / 8, (3 / 4 * pi * kappa)^(3 / 2) * (1 - 5 * kappa / 4),
112.04 * kappa^2 * exp(0.246 / kappa - a * kappa))
term1 <- ((1 - c * d^2) / (1 - d^2))^(5 / 2)
term2 <- 0
i_values <- c(-1, 0)
j_values <- 1:3
for (i in seq_along(i_values)) {
for (j in seq_along(j_values)) {
term2 <- term2 + cij[i, j] * kappa^i_values[i] * d^(2 * j_values[j])
}
}
term2 <- exp(term2 / (1 - d^2))
term3 <- exp(-d_val * kappa * a * b * (1 + b) * d^2 / (1 - b^2 * d^2))
term4 <- besselI(-d_val * kappa * a * (1 + b) * d / (1 - b^2 * d^2), nu = 0)
Q_r <- J_SYD * term1 * term2 * term3 * term4
return(Q_r)
}
# Leer los datos experimentales
zhou_data <- read.table("zhou_data.txt", header = FALSE, col.names = c("r", "p"))
zhou_data$r <- as.numeric(zhou_data$r)
zhou_data$p <- as.numeric(zhou_data$p)
# Transformar los datos experimentales
initial_lp <- 2.1
r_values <- zhou_data$r
p_values_initial <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, 13, initial_lp))
min_calculated <- min(p_values_initial)
max_calculated <- max(p_values_initial)
min_zhou <- min(zhou_data$p)
max_zhou <- max(zhou_data$p)
zhou_data$p_transformed <- min_calculated +
(max_calculated - min_calculated) * (zhou_data$p - min_zhou) / (max_zhou - min_zhou)
# Función para nls
calc_p <- function(r, lp) {
4 * pi * r^2 * calc_Q(r, 13, lp)
}
# Ajuste de los datos experimentales usando nls
fit <- nls(
p_transformed ~ calc_p(r, lp),
data = zhou_data,
start = list(lp = initial_lp)
)
# Valor de lp ajustado y desviación estándar
summary_fit <- summary(fit)
best_lp <- coef(summary_fit)["lp", "Estimate"]
std_error_lp <- coef(summary_fit)["lp", "Std. Error"]
cat("El mejor valor de lp es:", best_lp, "\n")
cat("La desviación estándar de lp es:", std_error_lp, "\n")
# Calcula p(r) con el mejor lp
p_values <- 4 * pi * r_values^2 * sapply(r_values, function(r) calc_Q(r, 13, best_lp))
# Crea un dataframe para ggplot
df <- data.frame(r = r_values, p = p_values)
# Gráfica
ggplot() +
geom_line(data = df, aes(x = r, y = p), color = "blue", size = 1, linetype = "solid") +
geom_point(data = zhou_data, aes(x = r, y = p_transformed), color = "red", size = 2) +
labs(
title = paste("Mejor ajuste con lp =", round(best_lp, 2), "±", round(std_error_lp, 2)),
x = "r",
y = "p(r, lp)",
color = "Datos"
) +
theme_minimal()
# Gráfica
ggplot() +
geom_line(data = df, aes(x = r, y = p), color = "blue", size = 1, linetype = "solid") +
geom_point(data = zhou_data, aes(x = r, y = p_transformed), color = "red", size = 2) +
labs(
x = "r",
y = "p(r, lp)",
color = "Datos"
) +
theme_minimal()
